# 30/60/90â€‘Day Onboarding Plan âœ¨ğŸ“˜ğŸš€

Break your first three months into clear milestones, pairing learning objectives with handsâ€‘on tasks drawn from the full onboarding guide. ğŸ—‚ï¸ğŸ§ ğŸ“…

---

## Days 1â€“30: Foundations & Local Rampâ€‘Up ğŸ› ï¸ğŸ§‘â€ğŸ’»ğŸ”

### Objectives

* Configure dev environments on Windows/macOS/Linux with Docker, Kubernetes CLI (`kubectl`), Python, Node.js, and VSâ€¯Code.
* Gain GitLab access: SSH keys, VPN/onâ€‘prem network, Docker registry credentials.
* Master Git workflows (branching, commit conventions, MRs) and bootstrap the codebase.
* Run the sample FastAPI/Flask + React app locally, both directly and via Docker Compose.

### Key Actions

1. **Environment & Tools Setup**

   * **Access**: Connect VPN or onâ€‘prem network; provision GitLab account; generate SSH key (`ssh-keygen -t ed25519 -C "you@company.com"`), add to GitLab. ğŸ”ğŸŒğŸ› ï¸
   * **Install per OS**:

     | Tool           | macOS                                  | Ubuntu                                    | Windows + WSL2                                |
     | -------------- | -------------------------------------- | ----------------------------------------- | --------------------------------------------- |
     | Git            | `brew install git`                     | `sudo apt update && sudo apt install git` | In WSL: `sudo apt install git`                |
     | Docker Engine  | `brew install docker` + Docker Desktop | `sudo apt install docker.io`              | Docker Desktop with WSL2 integration          |
     | Kubernetes CLI | `brew install kubectl`                 | `sudo snap install kubectl --classic`     | In WSL: `sudo snap install kubectl --classic` |
     | Python 3.10+   | `brew install python`                  | `sudo apt install python3 python3-venv`   | In WSL: same as Ubuntu                        |
     | Node.js & npm  | `brew install node`                    | `sudo apt install nodejs npm`             | In WSL: `nvm install node`                    |
     | VS Code        | Download from Microsoft site           | `snap install code --classic`             | Download + WSL extension                      |

2. **Clone & Bootstrap Project**

   * `git clone git@gitlab.company.com:team/project.git && cd project`
   * Copy environment: `cp .env.example .env`; fill secrets; ask DevOps lead as needed.
   * Run `docker-compose up --build` to launch backend (FastAPI/Flask), React frontend, local Postgres/MySQL, Redis.
   * *(Optional)* Virtualenv: `python3 -m venv .venv && source .venv/bin/activate && pip install -r requirements.txt`. ğŸ’»ğŸ“¦ğŸ”§

3. **Git & GitLab Basics**

   * Create feature branch: `git checkout -b feature/ABC-123-description`.
   * Commit with conventional messages (e.g., `feat(auth): add login endpoint`).
   * Open MR: include summary, ticket link, screenshots/API examples; assign reviewers; ensure pipeline (lint â†’ tests â†’ build) passes. ğŸ§ªğŸ“„ğŸ“¥

4. **Run & Extend Sample App**

   * Direct run:

     * Flask: `flask run --reload`
     * FastAPI: `uvicorn app.main:app --reload`
   * Curl test: `curl http://localhost:5000/api/message` â†’ JSON response.
   * React dev: `cd frontend && npm install && npm start`; verify UI.
   * Add a new endpoint (e.g., `/api/ping`), update React to fetch and display. ğŸ¯âš™ï¸ğŸ“Š

5. **Docker Workflow**

   * Write Dockerfile for service (use `python:3.10-slim`, leverage caching).
   * Build & run: `docker build -t sample-backend . && docker run -p 5000:5000 sample-backend`. ğŸ³ğŸ› ï¸ğŸ—ï¸

6. **Slack & Mentorship**

   * Join `#dev-team`, `#devops`, `#frontend`, `#backend`; introduce yourself.
   * Pairâ€‘program with mentor to explore architecture and repo structure. ğŸ¤ğŸ’¬ğŸ§­

---

## Days 31â€“60: Collaboration & Project Integration ğŸ§©ğŸ¤–ğŸ“¡

### Objectives

* Implement mediumâ€‘complexity DevOps tasks: multiâ€‘stage builds, review apps, and secrets management.
* Begin contributing to main project tickets; deploy to dev/staging using GitLab CI/CD and Helm.
* Build businessâ€‘use case: map UI for NF node visualization and simulated communication flows. ğŸŒğŸ“ˆğŸ”§

### Key Actions

1. **Multiâ€‘Stage Docker & CI**

   * Refactor Dockerfile: multiâ€‘stage build to minimize image size.
   * Update `.gitlab-ci.yml`: add multi-stage build job; define `stages: [lint, test, build, deploy]`.
   * Use CI variables for nonâ€‘sensitive configs; manage secrets via GitLab or Vault. ğŸ”âš™ï¸ğŸ› ï¸

2. **Review Apps & Environments**

   * Configure dynamic review apps: use GitLab environment naming `review/$CI_MERGE_REQUEST_IID`.
   * Auto-deploy with `helm install --namespace review-$CI_MERGE_REQUEST_IID sample ./sample-integration`. ğŸš€ğŸ“¦ğŸ§ª

3. **First Project Contribution**

   * Pick a small bug or feature from backlog; triage, estimate, branch, implement.
   * Write unit tests (pytest) and React tests (Jest/RTL); ensure coverage.
   * Open MR; collaborate on code review; merge into `develop` and deploy to staging. ğŸ“ğŸ§ªğŸ”

4. **Business Map UI Exercise**

   * **Backend**: ingest or mock NF nodes into Postgres; create endpoints:

     * `GET /api/nodes` â†’ list of `{ id, lat, lon, status }`
     * `GET /api/links` â†’ list of `{ from: nodeID, to: nodeID }`
   * **Frontend**: integrate Leaflet or Mapbox GL:

     * Fetch `/api/nodes`, place markers; add tooltips showing metadata.
     * Fetch `/api/links`, draw polylines; animate to show active comms.
   * Deploy to review/staging; gather feedback; iterate UI/UX. ğŸ—ºï¸ğŸ§­ğŸ“¡

5. **Helm Chart Introduction**

   * Scaffold chart: `helm create sample-integration`; configure `values.yaml`.
   * Template deployments and services for backend, frontend, map UI.
   * Parameterize images, replica counts, service types. ğŸ“¦ğŸ“ğŸ”

---

## Days 61â€“90: Advanced DevOps & Cloudâ€‘Native Delivery

### Objectives

* Master highâ€‘complexity deployment patterns: blue/green, canary releases, rollback strategies.
* Implement infrastructure as code (Terraform) with state management and module reuse.
* Integrate observability: metrics, logs, tracing (Prometheus, Grafana, ELK, Jaeger).
* Enhance security: container scanning, vulnerability assessments, RBAC, network policies.
* Package and promote the sample integration (including map UI) across environments (dev â†’ staging â†’ prod) via Helm.
* Define SRE practices: SLIs/SLOs, error budgets, and incident response playbooks.

### Key Actions

1. **Deployment Strategies & Traffic Management**

   * **Blue/Green Deployments**:

     * Create separate Kubernetes namespaces (`blue`, `green`) or duplicate services with distinct labels.
     * Use a fronting Ingress (NGINX, Istio Gateway) to switch traffic by updating VirtualService or Ingress rules.
   * **Canary Releases**:

     * Configure Istio DestinationRules and VirtualServices to split traffic (e.g., 10% to new version).
     * Automate canary promotion in CI: write a GitLab job that applies incremental weight changes and waits for health checks.
   * **Rollback Automation**:

     * Build a GitLab CI job that triggers `helm rollback` when health checks or metrics breach thresholds.

2. **Infrastructure as Code with Terraform**

   * **State Management**:

     * Store Terraform state in a secure, remote backend (e.g., Azure Blob, AWS S3 with locking via DynamoDB).
   * **Modular Design**:

     * Split infrastructure into reusable modules: network, Kubernetes cluster, VM provisioning, database.
     * Define input/output variables; version modules in a registry (GitLab or Terraform Cloud).
   * **CI/CD Integration**:

     * Add `terraform fmt`, `terraform validate`, `terraform plan` to the lint/test stages.
     * On merge to `main`, run `terraform apply` via a protected pipeline with manual approval.

3. **Observability & Monitoring**

   * **Metrics (Prometheus/Grafana)**:

     * Deploy Prometheus Operator; configure ServiceMonitors for backend, frontend, and map UI pods.
     * Create Grafana dashboards: request latency, error rate, resource usage, custom application metrics.
   * **Logging (ELK Stack or EFK)**:

     * Deploy Elasticsearch, Fluentd/FluentBit, and Kibana.
     * Label logs by environment and service; set up index lifecycle management for retention.
   * **Tracing (Jaeger/OpenTelemetry)**:

     * Instrument FastAPI/Flask with OpenTelemetry SDK; export traces to Jaeger.
     * Visualize request flows, identify latency hotspots.

4. **Security & Compliance**

   * **Container Scanning**:

     * Integrate GitLabâ€™s container scanning audit in the CI pipeline; fail builds on high-severity vulnerabilities.
   * **Image Signing & Policy Enforcement**:

     * Use Notary or Sigstore to sign images; enforce image provenance in admission controllers.
   * **Kubernetes Security**:

     * Define RBAC roles and RoleBindings per namespace; use PSP or PodSecurity admission to restrict privileges.
     * Apply network policies to limit pod-to-pod communication.
   * **Secret Management**:

     * Store secrets in Vault; integrate Vault Agent injector or External Secrets Operator for runtime injection.

5. **SRE & Operational Excellence**

   * **Define SLIs/SLOs**:

     * Write SLOs for API availability (e.g., 99.9% uptime) and latency (<200â€¯ms for 95th percentile).
     * Configure Prometheus alerts for alerting and incident response.
   * **Error Budgets & Runbooks**:

     * Track error budgets in dashboards; define escalation policies when budgets burn.
     * Write runbooks for common incident types (pod crash, high latency, unreachable services).
   * **Disaster Recovery Drills**:

     * Practice cluster failover: simulate zone/region outage and validate recovery procedures.

6. **Helm Chart Maturity & Promotion Pipeline**

   * **Environment Overlays**:

     * Maintain separate `values-dev.yaml`, `values-staging.yaml`, `values-prod.yaml`.
     * Use Helmfile or GitLabâ€™s review apps to manage multiple releases.
   * **Chart Testing**:

     * Integrate `helm lint` and `helm unittest` into CI pipeline.
     * Deploy to a temp namespace and run smoke tests before promoting.
   * **Promotion Workflow**:

     * Automate release gating: manual approval in GitLab before promoting charts from staging to prod.

7. **Endâ€‘toâ€‘End Demonstration & Documentation**

   * Host a live demo: showcase full lifecycle from commit to prod deploy, highlight blue/green switch, canary, metrics, and rollback.
   * Publish an internal case study: architecture diagrams, pipeline configuration, Terraform modules, Helm chart structure, observability dashboards.
   * Conduct a knowledge transfer session or brownâ€‘bag lunch for the team.

8. **Career Path & Specialization Planning**

   * Review performance with manager; set goals around areas of interest (security, platform engineering, SRE).
   * Identify advanced training or certifications (CKA/CKAD, Terraform Associate, CNCF programs).

*Remember to iterate frequently, collaborate crossâ€‘functionally, and document everything. Congratulations on reaching full onboarding capability!*
