# 30/60/90‑Day Onboarding Plan ✨📘🚀

Break your first three months into clear milestones, pairing learning objectives with hands‑on tasks drawn from the full onboarding guide. 🗂️🧠📅

---

## Days 1–30: Foundations & Local Ramp‑Up 🛠️🧑‍💻🔍

### Objectives

* Configure dev environments on Windows/macOS/Linux with Docker, Kubernetes CLI (`kubectl`), Python, Node.js, and VS Code.
* Gain GitLab access: SSH keys, VPN/on‑prem network, Docker registry credentials.
* Master Git workflows (branching, commit conventions, MRs) and bootstrap the codebase.
* Run the sample FastAPI/Flask + React app locally, both directly and via Docker Compose.

### Key Actions

1. **Environment & Tools Setup**

   * **Access**: Connect VPN or on‑prem network; provision GitLab account; generate SSH key (`ssh-keygen -t ed25519 -C "you@company.com"`), add to GitLab. 🔐🌐🛠️
   * **Install per OS**:

     | Tool           | macOS                                  | Ubuntu                                    | Windows + WSL2                                |
     | -------------- | -------------------------------------- | ----------------------------------------- | --------------------------------------------- |
     | Git            | `brew install git`                     | `sudo apt update && sudo apt install git` | In WSL: `sudo apt install git`                |
     | Docker Engine  | `brew install docker` + Docker Desktop | `sudo apt install docker.io`              | Docker Desktop with WSL2 integration          |
     | Kubernetes CLI | `brew install kubectl`                 | `sudo snap install kubectl --classic`     | In WSL: `sudo snap install kubectl --classic` |
     | Python 3.10+   | `brew install python`                  | `sudo apt install python3 python3-venv`   | In WSL: same as Ubuntu                        |
     | Node.js & npm  | `brew install node`                    | `sudo apt install nodejs npm`             | In WSL: `nvm install node`                    |
     | VS Code        | Download from Microsoft site           | `snap install code --classic`             | Download + WSL extension                      |

2. **Clone & Bootstrap Project**

   * `git clone git@gitlab.company.com:team/project.git && cd project`
   * Copy environment: `cp .env.example .env`; fill secrets; ask DevOps lead as needed.
   * Run `docker-compose up --build` to launch backend (FastAPI/Flask), React frontend, local Postgres/MySQL, Redis.
   * *(Optional)* Virtualenv: `python3 -m venv .venv && source .venv/bin/activate && pip install -r requirements.txt`. 💻📦🔧

3. **Git & GitLab Basics**

   * Create feature branch: `git checkout -b feature/ABC-123-description`.
   * Commit with conventional messages (e.g., `feat(auth): add login endpoint`).
   * Open MR: include summary, ticket link, screenshots/API examples; assign reviewers; ensure pipeline (lint → tests → build) passes. 🧪📄📥

4. **Run & Extend Sample App**

   * Direct run:

     * Flask: `flask run --reload`
     * FastAPI: `uvicorn app.main:app --reload`
   * Curl test: `curl http://localhost:5000/api/message` → JSON response.
   * React dev: `cd frontend && npm install && npm start`; verify UI.
   * Add a new endpoint (e.g., `/api/ping`), update React to fetch and display. 🎯⚙️📊

5. **Docker Workflow**

   * Write Dockerfile for service (use `python:3.10-slim`, leverage caching).
   * Build & run: `docker build -t sample-backend . && docker run -p 5000:5000 sample-backend`. 🐳🛠️🏗️

6. **Slack & Mentorship**

   * Join `#dev-team`, `#devops`, `#frontend`, `#backend`; introduce yourself.
   * Pair‑program with mentor to explore architecture and repo structure. 🤝💬🧭

---

## Days 31–60: Collaboration & Project Integration 🧩🤖📡

### Objectives

* Implement medium‑complexity DevOps tasks: multi‑stage builds, review apps, and secrets management.
* Begin contributing to main project tickets; deploy to dev/staging using GitLab CI/CD and Helm.
* Build business‑use case: map UI for NF node visualization and simulated communication flows. 🌐📈🔧

### Key Actions

1. **Multi‑Stage Docker & CI**

   * Refactor Dockerfile: multi‑stage build to minimize image size.
   * Update `.gitlab-ci.yml`: add multi-stage build job; define `stages: [lint, test, build, deploy]`.
   * Use CI variables for non‑sensitive configs; manage secrets via GitLab or Vault. 🔐⚙️🛠️

2. **Review Apps & Environments**

   * Configure dynamic review apps: use GitLab environment naming `review/$CI_MERGE_REQUEST_IID`.
   * Auto-deploy with `helm install --namespace review-$CI_MERGE_REQUEST_IID sample ./sample-integration`. 🚀📦🧪

3. **First Project Contribution**

   * Pick a small bug or feature from backlog; triage, estimate, branch, implement.
   * Write unit tests (pytest) and React tests (Jest/RTL); ensure coverage.
   * Open MR; collaborate on code review; merge into `develop` and deploy to staging. 📝🧪🔁

4. **Business Map UI Exercise**

   * **Backend**: ingest or mock NF nodes into Postgres; create endpoints:

     * `GET /api/nodes` → list of `{ id, lat, lon, status }`
     * `GET /api/links` → list of `{ from: nodeID, to: nodeID }`
   * **Frontend**: integrate Leaflet or Mapbox GL:

     * Fetch `/api/nodes`, place markers; add tooltips showing metadata.
     * Fetch `/api/links`, draw polylines; animate to show active comms.
   * Deploy to review/staging; gather feedback; iterate UI/UX. 🗺️🧭📡

5. **Helm Chart Introduction**

   * Scaffold chart: `helm create sample-integration`; configure `values.yaml`.
   * Template deployments and services for backend, frontend, map UI.
   * Parameterize images, replica counts, service types. 📦📐🔁

---

## Days 61–90: Advanced DevOps & Cloud‑Native Delivery

### Objectives

* Master high‑complexity deployment patterns: blue/green, canary releases, rollback strategies.
* Implement infrastructure as code (Terraform) with state management and module reuse.
* Integrate observability: metrics, logs, tracing (Prometheus, Grafana, ELK, Jaeger).
* Enhance security: container scanning, vulnerability assessments, RBAC, network policies.
* Package and promote the sample integration (including map UI) across environments (dev → staging → prod) via Helm.
* Define SRE practices: SLIs/SLOs, error budgets, and incident response playbooks.

### Key Actions

1. **Deployment Strategies & Traffic Management**

   * **Blue/Green Deployments**:

     * Create separate Kubernetes namespaces (`blue`, `green`) or duplicate services with distinct labels.
     * Use a fronting Ingress (NGINX, Istio Gateway) to switch traffic by updating VirtualService or Ingress rules.
   * **Canary Releases**:

     * Configure Istio DestinationRules and VirtualServices to split traffic (e.g., 10% to new version).
     * Automate canary promotion in CI: write a GitLab job that applies incremental weight changes and waits for health checks.
   * **Rollback Automation**:

     * Build a GitLab CI job that triggers `helm rollback` when health checks or metrics breach thresholds.

2. **Infrastructure as Code with Terraform**

   * **State Management**:

     * Store Terraform state in a secure, remote backend (e.g., Azure Blob, AWS S3 with locking via DynamoDB).
   * **Modular Design**:

     * Split infrastructure into reusable modules: network, Kubernetes cluster, VM provisioning, database.
     * Define input/output variables; version modules in a registry (GitLab or Terraform Cloud).
   * **CI/CD Integration**:

     * Add `terraform fmt`, `terraform validate`, `terraform plan` to the lint/test stages.
     * On merge to `main`, run `terraform apply` via a protected pipeline with manual approval.

3. **Observability & Monitoring**

   * **Metrics (Prometheus/Grafana)**:

     * Deploy Prometheus Operator; configure ServiceMonitors for backend, frontend, and map UI pods.
     * Create Grafana dashboards: request latency, error rate, resource usage, custom application metrics.
   * **Logging (ELK Stack or EFK)**:

     * Deploy Elasticsearch, Fluentd/FluentBit, and Kibana.
     * Label logs by environment and service; set up index lifecycle management for retention.
   * **Tracing (Jaeger/OpenTelemetry)**:

     * Instrument FastAPI/Flask with OpenTelemetry SDK; export traces to Jaeger.
     * Visualize request flows, identify latency hotspots.

4. **Security & Compliance**

   * **Container Scanning**:

     * Integrate GitLab’s container scanning audit in the CI pipeline; fail builds on high-severity vulnerabilities.
   * **Image Signing & Policy Enforcement**:

     * Use Notary or Sigstore to sign images; enforce image provenance in admission controllers.
   * **Kubernetes Security**:

     * Define RBAC roles and RoleBindings per namespace; use PSP or PodSecurity admission to restrict privileges.
     * Apply network policies to limit pod-to-pod communication.
   * **Secret Management**:

     * Store secrets in Vault; integrate Vault Agent injector or External Secrets Operator for runtime injection.

5. **SRE & Operational Excellence**

   * **Define SLIs/SLOs**:

     * Write SLOs for API availability (e.g., 99.9% uptime) and latency (<200 ms for 95th percentile).
     * Configure Prometheus alerts for alerting and incident response.
   * **Error Budgets & Runbooks**:

     * Track error budgets in dashboards; define escalation policies when budgets burn.
     * Write runbooks for common incident types (pod crash, high latency, unreachable services).
   * **Disaster Recovery Drills**:

     * Practice cluster failover: simulate zone/region outage and validate recovery procedures.

6. **Helm Chart Maturity & Promotion Pipeline**

   * **Environment Overlays**:

     * Maintain separate `values-dev.yaml`, `values-staging.yaml`, `values-prod.yaml`.
     * Use Helmfile or GitLab’s review apps to manage multiple releases.
   * **Chart Testing**:

     * Integrate `helm lint` and `helm unittest` into CI pipeline.
     * Deploy to a temp namespace and run smoke tests before promoting.
   * **Promotion Workflow**:

     * Automate release gating: manual approval in GitLab before promoting charts from staging to prod.

7. **End‑to‑End Demonstration & Documentation**

   * Host a live demo: showcase full lifecycle from commit to prod deploy, highlight blue/green switch, canary, metrics, and rollback.
   * Publish an internal case study: architecture diagrams, pipeline configuration, Terraform modules, Helm chart structure, observability dashboards.
   * Conduct a knowledge transfer session or brown‑bag lunch for the team.

8. **Career Path & Specialization Planning**

   * Review performance with manager; set goals around areas of interest (security, platform engineering, SRE).
   * Identify advanced training or certifications (CKA/CKAD, Terraform Associate, CNCF programs).

*Remember to iterate frequently, collaborate cross‑functionally, and document everything. Congratulations on reaching full onboarding capability!*
