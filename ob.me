# Comprehensive Onboarding Guide & 30/60/90â€‘Day Plan

Welcome aboard! This guide leads you through setting up your development environment, mastering workflows, and tackling handsâ€‘on exercises. By DaysÂ 30,Â 60, andÂ 90, youâ€™ll progress from foundational skills to advanced DevOps, cloudâ€‘native delivery, and SRE practices.

---

## SectionÂ 1: Development & Local Environment Setup

### 1.1 Supported Platforms

* WindowsÂ 10+ (use WSL2 for Linux tooling)
* macOSÂ 10.15+
* UbuntuÂ 18.04/20.04 (or similar modern distro)

### 1.2 Prerequisites & Credentials

1. VPN or onâ€‘prem network access
2. GitLab account with SSH key (`ssh-keygen -t ed25519 -C "you@company.com"`)
3. Docker registry credentials

### 1.3 Install Core Tools by OS

| Tool         | macOS                           | Ubuntu                                  | Windows + WSL2                 |
| ------------ | ------------------------------- | --------------------------------------- | ------------------------------ |
| Git          | `brew install git`              | `sudo apt updateÂ && apt install git`    | In WSL: `sudo apt install git` |
| Docker       | `brew install docker` + Desktop | `sudo apt install docker.io`            | Docker Desktop (enable WSL2)   |
| kubectl      | `brew install kubectl`          | `sudo snap install kubectl --classic`   | In WSL: same as Ubuntu         |
| PythonÂ 3.10+ | `brew install python@3.10`      | `sudo apt install python3 python3-venv` | In WSL: same as Ubuntu         |
| Node & npm   | `brew install node`             | `sudo apt install nodejs npm`           | In WSL: `nvm install node`     |
| VSÂ Code      | Download from Microsoft site    | `snap install code --classic`           | Download + WSL extension       |

---

## SectionÂ 2: Cloning & Bootstrapping

1. **Clone the repo**

   ```bash
   git clone git@gitlab.company.com:team/project.git && cd project
   ```
2. **Configure environments**

   ```bash
   cp .env.example .env
   # Edit .env with secrets (ask DevOps lead)
   ```
3. **Launch via Docker Compose**

   ```bash
   docker-compose up --build
   ```

   * Services: backend (FastAPI/Flask), frontend (React), Postgres/MySQL, Redis
4. **Optional: Python virtualenv**

   ```bash
   python3 -m venv .venv && source .venv/bin/activate
   pip install -r requirements.txt
   ```

---

## SectionÂ 3: Git & GitLab Workflows

### 3.1 Branching & Commits

* **Branches**: `main` (deployable), `develop` (integration), `feature/ABC-xxx`, `bugfix/ABC-xxx`
* **Commits**: imperative mood (`feat:`, `fix:`, etc.)

### 3.2 Merge Requests

1. Small scope (â‰¤Â 300Â lines)
2. Detailed description: summary, ticket link, screenshots or API examples
3. Assign 2+ reviewers (backend & frontend)
4. Ensure pipeline passes (lint â†’ tests â†’ build)
5. Merge after approvals

### 3.3 Code Reviews

* Check readability, test coverage, conventions
* Ask clarifying questions
* Provide constructive, respectful feedback

---

## SectionÂ 4: Docker & Kubernetes Basics

### 4.1 Docker Workflow

* **Dockerfile**: minimal base (`python:3.10-slim`), cacheâ€‘friendly layering
* **Local test**:

  ```bash
  docker build -t project-backend:dev .
  docker run --rm -p 8000:8000 project-backend:dev
  ```

### 4.2 Kubernetes Access

* Request `kubeconfig` from DevOps
* **Namespaces**: dev, staging, prod
* **kubectl**:

  ```bash
  kubectl get pods -n dev
  kubectl apply -f k8s/deployment.yaml -n dev
  kubectl logs -f <pod> -n dev
  ```
* **Helm**:

  ```bash
  helm install project ./helm-chart --namespace dev
  ```

---

## SectionÂ 5: Backend Frameworks

### 5.1 FastAPI

* Run: `uvicorn app.main:app --reload`
* Patterns: dependency injection, Pydantic models, async endpoints

### 5.2 Flask

* Run: `flask run --reload`
* Structure: use Blueprints for modular routing

> **Testing:** use Pytest for unit & integration tests alongside features

---

## SectionÂ 6: Frontend (React)

1. **Start dev server**:

   ```bash
   cd frontend && npm install && npm start
   ```
2. **Structure**: featureâ€‘based folders; shared UI in `/components/ui`
3. **Styling**: CSS Modules or styled-components
4. **API**: centralize in `/services/api.js` with Axios interceptors

---

## SectionÂ 7: Onâ€‘Prem Servers & VM Access

* **SSH**: `ssh ubuntu@10.0.5.12`
* **Paths**: `/opt/project` (app), `/var/log/project` (logs)
* **Maintenance**: `tmux`/`screen`, monitor with `df -h`, `top`

---

## SectionÂ 8: CI/CD Pipeline

* `.gitlab-ci.yml` stages: lint, test, build, deploy
* Artifacts: test reports, coverage badges
* Review apps: autoâ€‘spin per MR in namespace `mr-<ID>`

---

## SectionÂ 9: Communication & Resources

* Join relevant team communication channels for questions and collaboration.
* Refer to the internal knowledge base (e.g., GitLab Wiki) for design docs and architecture diagrams.
* Reach out to your assigned mentor or team lead for guidance.

---

## SectionÂ 10: Handsâ€‘On Exercise: Build & Integrate a Sample API + React App

### 10.1 Objectives

1. Scaffold a minimal REST API in **Flask** or **FastAPI**
2. Scaffold a minimal **React** app that fetches and displays data
3. Run both locally (via Docker or directly) and verify end-to-end integration

---

### 10.2 PartÂ 1 â€“ Backend API

1. **Create a new git repo** (or branch):

   ```bash
   mkdir sample-integration && cd sample-integration
   git init
   ```
2. **Choose your framework**

   * **Flask** example:

     ```bash
     python3 -m venv venv
     source venv/bin/activate
     pip install flask
     ```

     Create `app.py`:

     ```python
     from flask import Flask, jsonify

     app = Flask(__name__)

     @app.route("/api/message")
     def message():
         return jsonify({"message": "Hello from Flask!"})

     if __name__ == "__main__":
         app.run(host="0.0.0.0", port=5000, debug=True)
     ```
   * **FastAPI** example:

     ```bash
     python3 -m venv venv
     source venv/bin/activate
     pip install fastapi uvicorn
     ```

     Create `app.py`:

     ```python
     from fastapi import FastAPI

     app = FastAPI()

     @app.get("/api/message")
     async def message():
         return {"message": "Hello from FastAPI!"}
     ```

     Run with:

     ```bash
     uvicorn app:app --host 0.0.0.0 --port 5000 --reload
     ```
3. **Verify**

   ```bash
   curl http://localhost:5000/api/message
   # â†’ {"message":"Hello from Flask!"}  (or FastAPI)
   ```
4. *(Optional)* Dockerize the backend
   Create `Dockerfile`:

   ```dockerfile
   # Dockerfile
   FROM python:3.10-slim
   WORKDIR /app
   COPY app.py requirements.txt ./
   RUN pip install -r requirements.txt
   CMD ["python", "app.py"]
   ```

   Build & run:

   ```bash
   docker build -t sample-backend .
   docker run -p 5000:5000 sample-backend
   ```

---

### 10.3 PartÂ 2 â€“ React Frontend

1. **Scaffold**

   ```bash
   npx create-react-app sample-frontend
   cd sample-frontend
   ```
2. **Add a component**
   Edit `src/App.js` to fetch and display the message:

   ```jsx
   import { useEffect, useState } from "react";

   function App() {
     const [msg, setMsg] = useState("Loading...");

     useEffect(() => {
       fetch("http://localhost:5000/api/message")
         .then(res => res.json())
         .then(data => setMsg(data.message))
         .catch(() => setMsg("Failed to fetch"));
     }, []);

     return (
       <div style={{ padding: "2rem", fontFamily: "sans-serif" }}>
         <h1>Sample Integration</h1>
         <p>
           Message from API: <strong>{msg}</strong>
         </p>
       </div>
     );
   }

   export default App;
   ```
3. **Run**

   ```bash
   npm start
   ```

   * Browser opens at `http://localhost:3000` showing:

     > Message from API: *Hello from Flask!* (or FastAPI)
4. *(Optional)* Dockerize the frontend
   Create `Dockerfile`:

   ```dockerfile
   # Dockerfile
   FROM node:18-alpine AS build
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   RUN npm run build

   FROM nginx:alpine
   COPY --from=build /app/build /usr/share/nginx/html
   ```

   Build & run:

   ```bash
   docker build -t sample-frontend .
   docker run -p 3000:80 sample-frontend
   ```

---

### 10.4 PartÂ 3 â€“ Bring It Together

1. **Create `docker-compose.yml`** in `sample-integration/`:

   ```yaml
   version: "3.8"
   services:
     backend:
       build:
         context: .
         dockerfile: Dockerfile.backend   # your backend Dockerfile
       ports:
         - "5000:5000"
     frontend:
       build:
         context: sample-frontend
         dockerfile: Dockerfile.frontend  # your frontend Dockerfile
       ports:
         - "3000:80"
   ```
2. **Launch**

   ```bash
   docker-compose up --build
   ```
3. **Test End-to-End**

   * Visit `http://localhost:3000` and confirm the API message displays.
   * Inspect network requests to see calls to `localhost:5000/api/message`.

---

### 10.5 What to Submit

* A GitLab repo (or MR) containing:

  * `app.py`, `requirements.txt` (and backend Dockerfile)
  * `sample-frontend/` with modified `App.js` (and frontend Dockerfile)
  * `docker-compose.yml` at project root
* A short README with:

  * How to run locally
  * How to run via Docker/Docker Compose

---

This exercise reinforces:

* project bootstrapping
* minimal REST endpoints (Flask vs. FastAPI)
* React lifecycle & data fetching
* Docker & Compose workflows
* end-to-end connectivity

---

## SectionÂ 11: DevOps Tasks by Complexity

Break down GitLab CI/CD and infrastructure tasks into three stages of growing complexity. Each stage includes objectives, step-by-step actions, and success criteria.

### StageÂ 1 â€“ Low Complexity

**Objectives:** Get hands-on with CI basics and simple deployments.

**Tasks & Steps:**

1. **Basic Pipeline Setup**

   * Create `.gitlab-ci.yml` in the root:

     ```yaml
     stages:
       - lint
       - test
       - build
     lint_job:
       stage: lint
       script: npm run lint
     test_job:
       stage: test
       script: pytest
     build_job:
       stage: build
       script: docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA .
     ```
   * Commit & push to trigger pipeline; observe lint/test/build stages in GitLab UI.
2. **CI Variables**

   * Navigate to **SettingsÂ â†’ CI/CDÂ â†’ Variables** in your project.
   * Add non-sensitive vars (e.g., `API_URL`, `DB_NAME`);
   * Reference in `.gitlab-ci.yml` via `$VARIABLE_NAME`.
3. **Deploy to Dev VM**

   * Extend pipeline with a deploy job:

     ```yaml
     deploy_dev:
       stage: build
       script:
         - ssh ubuntu@DEV_VM_IP "docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA && docker run -d --rm -p 5000:5000 $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
       only:
         - develop
     ```
   * Confirm app is reachable at `http://DEV_VM_IP:5000`.

**Success Criteria:** Pipeline runs without errors; environment variables injected; dev VM deploys on `develop` branch pushes.

---

### StageÂ 2 â€“ Medium Complexity

**Objectives:** Introduce multi-stage builds, dynamic review apps, and secure secrets handling.

**Tasks & Steps:**

1. **Multi-Stage Docker Builds**

   * Update `Dockerfile`:

     ```dockerfile
     FROM node:18-alpine AS build
     WORKDIR /app
     COPY package*.json ./
     RUN npm install
     COPY . .
     RUN npm run build

     FROM nginx:alpine
     COPY --from=build /app/build /usr/share/nginx/html
     ```
   * Adjust CI to build multi-stage and push optimized image.
2. **Dynamic Review Apps**

   * Add a review app job:

     ```yaml
     review_app:
       stage: deploy
       script:
         - helm upgrade --install review-$CI_MERGE_REQUEST_IID ./helm-chart --namespace review-namespace
       when: manual
       only:
         - merge_requests
     ```
   * Review apps spin up per MR; testers can access unique URLs.
3. **Secrets Management**

   * Integrate HashiCorp Vault or GitLab managed secrets:

     * Store sensitive values in Vault; use Vault agent or GitLab secrets masked variables.
   * Modify CI to authenticate and fetch secrets:

     ```yaml
     vault_fetch:
       script:
         - vault login $VAULT_TOKEN
         - vault kv get -format=json secret/app > secrets.json
     ```

**Success Criteria:** Multi-stage images under 100Â MB; review apps deploy automatically per MR; secrets are not logged and accessible to pipelines.

---

### StageÂ 3 â€“ High Complexity

**Objectives:** Implement advanced deployment patterns, infrastructure as code, and traffic management.

**Tasks & Steps:**

1. **Blue/Green Deployments**

   * Maintain two deployments: `app-blue` & `app-green` in Kubernetes.
   * Use an Ingress or service to switch traffic labels:

     ```bash
     kubectl set selector svc/app selector=version=green
     ```
   * Automate switch via CI job with health checks:

     ```yaml
     blue_green_switch:
       stage: deploy
       script:
         - helm upgrade green ./helm-chart --set image.tag=$NEW_TAG
         - run health tests
         - helm switch traffic to green
       when: manual
     ```
2. **Canary Releases**

   * Configure Istio VirtualService to route a portion of traffic:

     ```yaml
     apiVersion: networking.istio.io/v1alpha3
     kind: VirtualService
     spec:
       http:
         - route:
             - destination: { host: app, subset: v1, weight: 90 }
             - destination: { host: app, subset: v2, weight: 10 }
     ```
   * Adjust weights in incremental steps within CI and monitor metrics.
3. **Terraform Infrastructure as Code (IaC)**

   * Structure Terraform modules:

     ```
     modules/
       network/
       kubernetes-cluster/
       database/
     main.tf
     variables.tf
     outputs.tf
     ```
   * Configure remote state:

     ```hcl
     terraform {
       backend "s3" {
         bucket = "project-terraform-state"
         key    = "env:terraform.tfstate"
         region = "us-east-1"
         dynamodb_table = "terraform-lock"
       }
     }
     ```
   * Add CI jobs:

     ```yaml
     terraform_plan:
       stage: test
       script:
         - terraform init
         - terraform plan
     terraform_apply:
       stage: deploy
       when: manual
       script:
         - terraform apply -auto-approve
     ```
4. **Observability & Monitoring**

   * Deploy Prometheus Operator and Grafana via Helm; configure ServiceMonitors.
   * Create dashboards for CPU, memory, request latency, error rates.
   * Instrument application with OpenTelemetry for distributed tracing.
5. **Traffic Shaping & Rollbacks**

   * Implement automated rollback CI job triggered if health metrics degrade:

     ```yaml
     rollback_job:
       stage: deploy
       script:
         - helm rollback my-release 1
       when: on_failure
     ```

**Success Criteria:** Automated canary and blue/green rollouts; Terraform modules provision infra reliably; end-to-end monitoring with alerts and trace visualization.

---

## SectionÂ 12: Business Use Case â€“ NF Map UI

Leverage the above DevOps practices to build and deploy a telecom use case that visualizes NF (network function) nodes and their links on a map.

### 12.1 Data Layer & Backend

1. **Data Ingestion**

   * Create a Python script to mock or import NF node data into PostgreSQL:

     ```python
     import psycopg2
     nodes = [ ... ]
     conn = psycopg2.connect(...)
     cur = conn.cursor()
     for n in nodes:
         cur.execute("INSERT INTO nodes (id, lat, lon, status) VALUES (%s, %s, %s, %s)", n)
     conn.commit()
     ```
2. **API Endpoints**

   * Extend FastAPI/Flask app:

     ```python
     @app.get("/api/nodes")
     def get_nodes():
         return db.query_all_nodes()

     @app.get("/api/links")
     def get_links():
         return db.query_all_links()
     ```
3. **CI/CD**

   * Add migrations and data load to pipeline:

     ```yaml
     migrate:
       stage: deploy
       script:
         - alembic upgrade head
         - python scripts/load_nodes.py
     ```

### 12.2 Frontend Map UI

1. **Setup Map Library**

   * Install Leaflet or Mapbox GL: `npm install leaflet react-leaflet`
2. **Render Nodes**

   ```jsx
   import { MapContainer, TileLayer, Marker, Popup } from 'react-leaflet';
   function MapView() {
     const [nodes, setNodes] = useState([]);
     useEffect(() => {
       fetch('/api/nodes')
         .then(r => r.json())
         .then(setNodes);
     }, []);
     return (
       <MapContainer center={[0,0]} zoom={2} style={{ height: '100%' }}>
         <TileLayer url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" />
         {nodes.map(n => (
           <Marker key={n.id} position={[n.lat, n.lon]}>
             <Popup>{`ID: ${n.id}, Status: ${n.status}`}</Popup>
           </Marker>
         ))}
       </MapContainer>
     );
   }
   ```
3. **Render Links**

   ```jsx
   import { Polyline } from 'react-leaflet';
   useEffect(() => {
     fetch('/api/links')
       .then(r => r.json())
       .then(setLinks);
   }, []);
   return links.map(link => {
     const from = nodes.find(n => n.id === link.from);
     const to = nodes.find(n => n.id === link.to);
     return <Polyline key={`${link.from}-${link.to}`} positions={[[from.lat, from.lon],[to.lat,to.lon]]} />;
   });
   ```
4. **Animate & Style**

   * Use Leaflet pulse markers or CSS animations to indicate active links.
5. **Deployment**

   * Package frontend into Docker, deploy via Helm chart under `map-ui` subchart.

**Success Criteria:** Interactive map displaying nodes and links, deployed through CI/CD to staging or production.

---

## SectionÂ 13: Cloudâ€‘Native Principles & Helm Charts

Package the entire sample integration (backend, frontend, map UI) into a single Helm chart with environment overlays.

### 13.1 Chart Scaffold & Structure

1. Scaffold:

   ```bash
   helm create sample-integration
   ```
2. Directory overview:

   ```
   ```

templates/
deployment.yaml
service.yaml
ingress.yaml
\_helpers.tpl
values.yaml
Chart.yaml

````

### 13.2 values.yaml Configuration
```yaml
replicaCount: 2
image:
repository: $CI_REGISTRY_IMAGE
pullPolicy: IfNotPresent
tag: $CI_COMMIT_SHORT_SHA
service:
type: LoadBalancer
port: 80
ingress:
enabled: true
hosts:
 - host: sample-integration.local
   paths: ['/']
````

### 13.3 Templating Deployments & Services

* **Deployment**: parameterize image and replicas.
* **Service**: expose ports; use clusterIP for internal services.
* **Ingress**: host and path rules for both frontend and backend using subpaths or subdomains.

### 13.4 Environment Overlays & Promotion

1. Create `values-dev.yaml`, `values-staging.yaml`, `values-prod.yaml` with overrides:

   ```yaml
   replicaCount: 1
   image:
     tag: dev-latest
   ```
2. Promotion pipeline:

   ```yaml
   deploy_dev:
     stage: deploy
     script: helm upgrade --install sample-integration ./sample-integration -f values-dev.yaml
   deploy_staging:
     stage: deploy
     when: manual
     script: helm upgrade --install sample-integration ./sample-integration -f values-staging.yaml
   deploy_prod:
     stage: deploy
     when: manual
     script: helm upgrade --install sample-integration ./sample-integration -f values-prod.yaml
   ```

### 13.5 Testing & Validation

* **Lint & Unit Tests**:

  ```bash
  helm lint sample-integration
  helm unittest sample-integration
  ```
* **Smoke Tests**:

  * After deploy, run basic HTTP checks against health endpoints.
* **Rollback**:

  ```bash
  helm rollback sample-integration 1
  ```

### 13.6 Key Cloudâ€‘Native Principles

* **Immutable Artifacts**: every release uses a new container image tag.
* **Declarative Configuration**: all desired state defined in YAML templates.
* **Reusability**: parameterized charts for different environments.
* **Observability**: include ServiceMonitor manifests and metrics scraping when relevant.

---

# 30/60/90â€‘Day Plan âœ¨ðŸ“˜ðŸš€

### DaysÂ 1â€“30: Foundations

* Set up environments, GitLab access, Docker Compose
* Complete GitLab workflow, bootstrap code, run sample app
* Extend sample API & React component, merge MR

### DaysÂ 31â€“60: Integration

* Implement mediumâ€‘complexity DevOps tasks
* Contribute code tickets, write tests, deploy to staging
* Build NF map UI & demo

### DaysÂ 61â€“90: Mastery

* Advanced DevOps (blue/green, canary, rollback)
* Terraform IaC modules & remote state
* Observability: Prometheus, Grafana, ELK, tracing
* Security: scanning, RBAC, network policies, Vault
* SRE: SLIs/SLOs, error budgets, runbooks, DR drills
* Helm promotion pipeline & live demo
* Document case study & host knowledge share
* Plan nextâ€‘step certifications (CKA, Terraform, CNCF)

*Remember: collaborate, ask questions, document your journey!*/90â€‘Day Plan âœ¨ðŸ“˜ðŸš€

### DaysÂ 1â€“30: Foundations

* Set up environments, GitLab access, Docker Compose
* Complete GitLab workflow, bootstrap code, run sample app
* Extend sample API & React component, merge MR

### DaysÂ 31â€“60: Integration

* Implement mediumâ€‘complexity DevOps tasks
* Contribute code tickets, write tests, deploy to staging
* Build NF map UI & demo

### DaysÂ 61â€“90: Mastery

* Advanced DevOps (blue/green, canary, rollback)
* Terraform IaC modules & remote state
* Observability: Prometheus, Grafana, ELK, tracing
* Security: scanning, RBAC, network policies, Vault
* SRE: SLIs/SLOs, error budgets, runbooks, DR drills
* Helm promotion pipeline & live demo
* Document case study & host knowledge share
* Plan nextâ€‘step certifications (CKA, Terraform, CNCF)

*Remember: collaborate, ask questions, document your journey!*
